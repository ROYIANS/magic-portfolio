# Magic Portfolio + Halo API ÊäÄÊúØËßÑËåÉ

## Êû∂ÊûÑËÆæËÆ°Âõæ

```mermaid
graph TB
    subgraph "ÂâçÁ´ØÂ±Ç (Next.js)"
        A[È°µÈù¢ÁªÑ‰ª∂] --> B[‰∏öÂä°ÁªÑ‰ª∂]
        B --> C[Êï∞ÊçÆÈÄÇÈÖçÂô®]
    end
    
    subgraph "ÊúçÂä°Â±Ç"
        C --> D[Post Service]
        C --> E[Category Service] 
        C --> F[Tag Service]
        D --> G[API Client]
        E --> G
        F --> G
    end
    
    subgraph "ÁºìÂ≠òÂ±Ç"
        G --> H[Next.js Cache]
        H --> I[ISR Cache]
        I --> J[CDN Cache]
    end
    
    subgraph "ÂêéÁ´ØÂ±Ç (Halo)"
        G --> K[Halo Public API]
        K --> L[Halo Core]
        L --> M[Êï∞ÊçÆÂ∫ì]
    end
    
    subgraph "ÈôçÁ∫ßÁ≠ñÁï•"
        D --> N[Êú¨Âú∞Êñá‰ª∂Á≥ªÁªü]
        N --> O[MDX Êñá‰ª∂]
    end
```

## ËØ¶ÁªÜÊäÄÊúØÂÆûÁé∞

### 1. È°πÁõÆÁªìÊûÑÈáçÁªÑ

```
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ halo-client.ts          # Halo API ÂÆ¢Êà∑Á´ØÈÖçÁΩÆ
‚îÇ   ‚îú‚îÄ‚îÄ cache.ts                # ÁºìÂ≠òÁÆ°ÁêÜ
‚îÇ   ‚îî‚îÄ‚îÄ adapters/               # Êï∞ÊçÆÈÄÇÈÖçÂô®
‚îÇ       ‚îú‚îÄ‚îÄ post-adapter.ts     # ÊñáÁ´†Êï∞ÊçÆÊò†Â∞Ñ
‚îÇ       ‚îú‚îÄ‚îÄ category-adapter.ts # ÂàÜÁ±ªÊï∞ÊçÆÊò†Â∞Ñ
‚îÇ       ‚îî‚îÄ‚îÄ tag-adapter.ts      # Ê†áÁ≠æÊï∞ÊçÆÊò†Â∞Ñ
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ post-service.ts         # ÊñáÁ´†ÊúçÂä°
‚îÇ   ‚îú‚îÄ‚îÄ category-service.ts     # ÂàÜÁ±ªÊúçÂä°
‚îÇ   ‚îú‚îÄ‚îÄ tag-service.ts          # Ê†áÁ≠æÊúçÂä°
‚îÇ   ‚îî‚îÄ‚îÄ fallback-service.ts     # ÈôçÁ∫ßÊúçÂä°
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ halo.ts                 # Halo API Á±ªÂûãÂÆö‰πâ
‚îÇ   ‚îî‚îÄ‚îÄ local.ts                # Êú¨Âú∞Êï∞ÊçÆÁ±ªÂûã
‚îî‚îÄ‚îÄ hooks/
    ‚îú‚îÄ‚îÄ use-posts.ts            # ÊñáÁ´†Êï∞ÊçÆ Hook
    ‚îî‚îÄ‚îÄ use-categories.ts       # ÂàÜÁ±ªÊï∞ÊçÆ Hook
```

### 2. API ÂÆ¢Êà∑Á´ØËØ¶ÁªÜÈÖçÁΩÆ

```typescript
// src/lib/halo-client.ts
import axios, { AxiosError, AxiosResponse } from 'axios';
import { 
  createPublicApiClient, 
  createConsoleApiClient,
  PublicApiClient,
  ConsoleApiClient
} from '@halo-dev/api-client';

interface HaloClientConfig {
  baseURL: string;
  timeout: number;
  retryCount: number;
  retryDelay: number;
}

class HaloApiClient {
  private config: HaloClientConfig;
  private axiosInstance;
  public publicApi: PublicApiClient;
  public consoleApi: ConsoleApiClient;

  constructor(config: HaloClientConfig) {
    this.config = config;
    this.setupAxiosInstance();
    this.setupApiClients();
  }

  private setupAxiosInstance() {
    this.axiosInstance = axios.create({
      baseURL: this.config.baseURL,
      timeout: this.config.timeout,
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.HALO_API_TOKEN}`,
      },
    });

    // ËØ∑Ê±ÇÊã¶Êà™Âô®
    this.axiosInstance.interceptors.request.use(
      (config) => {
        console.log(`üöÄ API Request: ${config.method?.toUpperCase()} ${config.url}`);
        return config;
      },
      (error) => Promise.reject(error)
    );

    // ÂìçÂ∫îÊã¶Êà™Âô®
    this.axiosInstance.interceptors.response.use(
      (response: AxiosResponse) => {
        console.log(`‚úÖ API Success: ${response.config.url} (${response.status})`);
        return response;
      },
      async (error: AxiosError) => {
        console.error(`‚ùå API Error: ${error.config?.url}`, error.response?.data);
        
        // ÂÆûÁé∞ÈáçËØïÊú∫Âà∂
        if (error.response?.status === 429 || error.response?.status >= 500) {
          return this.retryRequest(error);
        }
        
        return Promise.reject(error);
      }
    );
  }

  private async retryRequest(error: AxiosError, retryCount = 0): Promise<any> {
    if (retryCount >= this.config.retryCount) {
      return Promise.reject(error);
    }

    await this.delay(this.config.retryDelay * Math.pow(2, retryCount));
    
    try {
      return await this.axiosInstance.request(error.config!);
    } catch (retryError) {
      return this.retryRequest(error, retryCount + 1);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private setupApiClients() {
    this.publicApi = createPublicApiClient(this.axiosInstance);
    this.consoleApi = createConsoleApiClient(this.axiosInstance);
  }
}

// Âçï‰æãÂÆû‰æã
export const haloClient = new HaloApiClient({
  baseURL: process.env.HALO_API_BASE_URL || 'http://localhost:8090',
  timeout: 10000,
  retryCount: 3,
  retryDelay: 1000,
});
```

### 3. ÂÆåÊï¥ÁöÑÊï∞ÊçÆÈÄÇÈÖçÂô®Á≥ªÁªü

```typescript
// src/lib/adapters/post-adapter.ts
import { HaloPost, LocalPost } from '@/types';

export class PostAdapter {
  static haloToLocal(haloPost: HaloPost): LocalPost {
    return {
      slug: haloPost.spec.slug,
      metadata: {
        title: haloPost.spec.title,
        publishedAt: haloPost.spec.publishTime || haloPost.metadata.creationTimestamp,
        summary: haloPost.status.excerpt || haloPost.spec.excerpt.raw || '',
        image: haloPost.spec.cover,
        images: this.extractImagesFromContent(haloPost.content?.content),
        tag: haloPost.spec.tags?.[0],
        team: [], // ÈúÄË¶Å‰ªé contributors Êò†Â∞Ñ
        link: haloPost.status.permalink,
      },
      content: haloPost.content?.content || '',
      rawContent: haloPost.content?.raw || '',
      stats: {
        visits: haloPost.stats.visit,
        comments: haloPost.stats.comment,
        upvotes: haloPost.stats.upvote,
      },
      categories: haloPost.categories?.map(cat => ({
        name: cat.metadata.name,
        displayName: cat.spec.displayName,
        slug: cat.spec.slug,
        permalink: cat.status.permalink,
      })) || [],
      tags: haloPost.tags?.map(tag => ({
        name: tag.metadata.name,
        displayName: tag.spec.displayName,
        slug: tag.spec.slug,
        color: tag.spec.color,
        permalink: tag.status.permalink,
      })) || [],
    };
  }

  static localToHalo(localPost: LocalPost): Partial<HaloPost> {
    return {
      spec: {
        title: localPost.metadata.title,
        slug: localPost.slug,
        cover: localPost.metadata.image,
        publishTime: localPost.metadata.publishedAt,
        excerpt: {
          autoGenerate: !localPost.metadata.summary,
          raw: localPost.metadata.summary,
        },
        tags: localPost.metadata.tag ? [localPost.metadata.tag] : [],
        categories: [],
        visible: "PUBLIC",
        allowComment: true,
        pinned: false,
        priority: 0,
        publish: true,
      },
    };
  }

  private static extractImagesFromContent(content?: string): string[] {
    if (!content) return [];
    
    const imageRegex = /<img[^>]+src="([^">]+)"/g;
    const images: string[] = [];
    let match;
    
    while ((match = imageRegex.exec(content)) !== null) {
      images.push(match[1]);
    }
    
    return images;
  }
}
```

### 4. ÊúçÂä°Â±ÇËØ¶ÁªÜÂÆûÁé∞

```typescript
// src/services/post-service.ts
import { haloClient } from '@/lib/halo-client';
import { PostAdapter } from '@/lib/adapters/post-adapter';
import { ApiErrorHandler } from '@/lib/error-handler';

export interface GetPostsOptions {
  page?: number;
  size?: number;
  categoryName?: string;
  tagName?: string;
  sort?: string[];
  keyword?: string;
}

export class PostService {
  async getPosts(options: GetPostsOptions = {}): Promise<LocalPost[]> {
    return ApiErrorHandler.withFallback(
      async () => {
        const response = await haloClient.publicApi.content.post.queryPosts({
          page: options.page || 0,
          size: options.size || 20,
          sort: options.sort || ['spec.publishTime,desc'],
        });

        // ÊâπÈáèËé∑ÂèñÊñáÁ´†ÂÜÖÂÆπ
        const postsWithContent = await Promise.all(
          response.data.items.map(async (post) => {
            try {
              const contentResponse = await haloClient.publicApi.content.post
                .queryPostByName(post.metadata.name);
              return { ...post, content: contentResponse.data.content };
            } catch (error) {
              console.warn(`Failed to fetch content for post ${post.metadata.name}:`, error);
              return post;
            }
          })
        );

        return postsWithContent.map(PostAdapter.haloToLocal);
      },
      [] // Á©∫Êï∞ÁªÑ‰Ωú‰∏∫ÈôçÁ∫ßÂÄº
    );
  }

  async getPostBySlug(slug: string): Promise<LocalPost | null> {
    return ApiErrorHandler.withFallback(
      async () => {
        // Áî±‰∫é Halo API ‰∏çÁõ¥Êé•ÊîØÊåÅÊåâ slug Êü•ËØ¢ÔºåÈúÄË¶ÅÂÖàËé∑ÂèñÂàóË°®ÂÜçËøáÊª§
        const posts = await this.getPosts({ size: 1000 });
        return posts.find(post => post.slug === slug) || null;
      },
      null
    );
  }

  async getPostsByCategory(categorySlug: string, options: GetPostsOptions = {}): Promise<LocalPost[]> {
    return ApiErrorHandler.withFallback(
      async () => {
        const response = await haloClient.publicApi.content.category
          .queryPostsByCategoryName(categorySlug, {
            page: options.page || 0,
            size: options.size || 20,
            sort: options.sort || ['spec.publishTime,desc'],
          });

        return response.data.items.map(PostAdapter.haloToLocal);
      },
      []
    );
  }

  async getPostsByTag(tagSlug: string, options: GetPostsOptions = {}): Promise<LocalPost[]> {
    return ApiErrorHandler.withFallback(
      async () => {
        const response = await haloClient.publicApi.content.tag
          .queryPostsByTagName(tagSlug, {
            page: options.page || 0,
            size: options.size || 20,
            sort: options.sort || ['spec.publishTime,desc'],
          });

        return response.data.items.map(PostAdapter.haloToLocal);
      },
      []
    );
  }
}
```

### 5. React Hooks ÈõÜÊàê

```typescript
// src/hooks/use-posts.ts
import { useState, useEffect } from 'react';
import { PostService, GetPostsOptions } from '@/services/post-service';

export function usePosts(options: GetPostsOptions = {}) {
  const [posts, setPosts] = useState<LocalPost[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let isMounted = true;

    const fetchPosts = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const postService = new PostService();
        const fetchedPosts = await postService.getPosts(options);
        
        if (isMounted) {
          setPosts(fetchedPosts);
        }
      } catch (err) {
        if (isMounted) {
          setError(err instanceof Error ? err : new Error('Unknown error'));
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    };

    fetchPosts();

    return () => {
      isMounted = false;
    };
  }, [JSON.stringify(options)]);

  return { posts, loading, error, refetch: () => fetchPosts() };
}
```

### 6. Next.js API Ë∑ØÁî±ÂÆûÁé∞

```typescript
// src/app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PostService } from '@/services/post-service';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  
  const options = {
    page: Number(searchParams.get('page')) || 0,
    size: Number(searchParams.get('size')) || 20,
    categoryName: searchParams.get('category') || undefined,
    tagName: searchParams.get('tag') || undefined,
    keyword: searchParams.get('keyword') || undefined,
  };

  try {
    const postService = new PostService();
    const posts = await postService.getPosts(options);

    return NextResponse.json({
      success: true,
      data: posts,
      pagination: {
        page: options.page,
        size: options.size,
        total: posts.length,
      },
    });
  } catch (error) {
    console.error('API Error:', error);
    
    return NextResponse.json(
      {
        success: false,
        error: 'Failed to fetch posts',
        message: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}
```

### 7. ÁéØÂ¢ÉÈÖçÁΩÆÁÆ°ÁêÜ

```typescript
// src/config/halo.ts
interface HaloConfig {
  apiBaseUrl: string;
  apiToken: string;
  enableFallback: boolean;
  cacheTimeout: number;
  retryConfig: {
    count: number;
    delay: number;
  };
}

export const haloConfig: HaloConfig = {
  apiBaseUrl: process.env.HALO_API_BASE_URL || 'http://localhost:8090',
  apiToken: process.env.HALO_API_TOKEN || '',
  enableFallback: process.env.HALO_ENABLE_FALLBACK === 'true',
  cacheTimeout: Number(process.env.HALO_CACHE_TIMEOUT) || 300,
  retryConfig: {
    count: Number(process.env.HALO_RETRY_COUNT) || 3,
    delay: Number(process.env.HALO_RETRY_DELAY) || 1000,
  },
};

// ÁéØÂ¢ÉÂèòÈáèÈ™åËØÅ
export function validateHaloConfig(): boolean {
  const required = ['HALO_API_BASE_URL', 'HALO_API_TOKEN'];
  const missing = required.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    console.error(`Missing required environment variables: ${missing.join(', ')}`);
    return false;
  }
  
  return true;
}
```

### 8. ÁºìÂ≠òÁ≠ñÁï•ÂÆûÁé∞

```typescript
// src/lib/cache.ts
import { unstable_cache } from 'next/cache';
import { PostService, GetPostsOptions } from '@/services/post-service';

// ÊñáÁ´†ÂàóË°®ÁºìÂ≠ò
export const getCachedPosts = unstable_cache(
  async (options: GetPostsOptions = {}) => {
    const postService = new PostService();
    return await postService.getPosts(options);
  },
  ['halo-posts'],
  {
    revalidate: 300, // 5ÂàÜÈíü
    tags: ['posts'],
  }
);

// Âçï‰∏™ÊñáÁ´†ÁºìÂ≠ò
export const getCachedPost = unstable_cache(
  async (slug: string) => {
    const postService = new PostService();
    return await postService.getPostBySlug(slug);
  },
  ['halo-post'],
  {
    revalidate: 600, // 10ÂàÜÈíü
    tags: ['post'],
  }
);

// ÂàÜÁ±ªÁºìÂ≠ò
export const getCachedCategories = unstable_cache(
  async () => {
    const categoryService = new CategoryService();
    return await categoryService.getCategories();
  },
  ['halo-categories'],
  {
    revalidate: 1800, // 30ÂàÜÈíü
    tags: ['categories'],
  }
);

// ÊâãÂä®ÁºìÂ≠òÂ§±Êïà
export async function revalidateCache(tag: string) {
  const { revalidateTag } = await import('next/cache');
  revalidateTag(tag);
}
```

### 9. ÈîôËØØÂ§ÑÁêÜÂíåÁõëÊéß

```typescript
// src/lib/error-handler.ts
export enum ErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',
  API_ERROR = 'API_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

export interface ApiError {
  type: ErrorType;
  message: string;
  code?: string;
  details?: any;
  timestamp: Date;
}

export class ApiErrorHandler {
  static async withFallback<T>(
    apiCall: () => Promise<T>,
    fallback: T,
    errorCallback?: (error: ApiError) => void
  ): Promise<T> {
    try {
      return await apiCall();
    } catch (error) {
      const apiError = this.normalizeError(error);
      
      // ËÆ∞ÂΩïÈîôËØØ
      this.logError(apiError);
      
      // Ë∞ÉÁî®ÈîôËØØÂõûË∞É
      if (errorCallback) {
        errorCallback(apiError);
      }
      
      // ËøîÂõûÈôçÁ∫ßÂÄº
      return fallback;
    }
  }

  private static normalizeError(error: any): ApiError {
    if (error.response) {
      // HTTP ÈîôËØØ
      return {
        type: ErrorType.API_ERROR,
        message: error.response.data?.message || error.message,
        code: error.response.status.toString(),
        details: error.response.data,
        timestamp: new Date(),
      };
    } else if (error.request) {
      // ÁΩëÁªúÈîôËØØ
      return {
        type: ErrorType.NETWORK_ERROR,
        message: 'Network connection failed',
        details: error.request,
        timestamp: new Date(),
      };
    } else {
      // ÂÖ∂‰ªñÈîôËØØ
      return {
        type: ErrorType.UNKNOWN_ERROR,
        message: error.message || 'Unknown error occurred',
        timestamp: new Date(),
      };
    }
  }

  private static logError(error: ApiError) {
    console.error(`[${error.type}] ${error.message}`, {
      code: error.code,
      details: error.details,
      timestamp: error.timestamp,
    });
    
    // Áîü‰∫ßÁéØÂ¢É‰∏≠ÂèØ‰ª•ÂèëÈÄÅÂà∞ÁõëÊéßÊúçÂä°
    if (process.env.NODE_ENV === 'production') {
      // ‰æãÂ¶ÇÔºöÂèëÈÄÅÂà∞ Sentry, LogRocket Á≠â
    }
  }
}
```

### 10. Á±ªÂûãÂÆö‰πâÁ≥ªÁªü

```typescript
// src/types/halo.ts
export interface HaloListResult<T> {
  first: boolean;
  hasNext: boolean;
  hasPrevious: boolean;
  items: T[];
  last: boolean;
  page: number;
  size: number;
  total: number;
  totalPages: number;
}

export interface HaloMetadata {
  name: string;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
  creationTimestamp: string;
  version?: number;
}

export interface HaloPostSpec {
  title: string;
  slug: string;
  cover?: string;
  publishTime?: string;
  excerpt: {
    autoGenerate: boolean;
    raw?: string;
  };
  categories: string[];
  tags: string[];
  visible: "PUBLIC" | "INTERNAL" | "PRIVATE";
  allowComment: boolean;
  pinned: boolean;
  priority: number;
  template?: string;
  owner: string;
  deleted: boolean;
  publish: boolean;
}

export interface HaloPostStatus {
  permalink: string;
  excerpt: string;
  lastModifyTime: string;
  commentsCount: number;
  contributors: string[];
  inProgress: boolean;
  observedVersion?: number;
  phase?: string;
}

export interface HaloPost {
  metadata: HaloMetadata;
  spec: HaloPostSpec;
  status: HaloPostStatus;
  stats: {
    visit: number;
    upvote: number;
    comment: number;
  };
  content?: {
    content: string;
    raw: string;
  };
  categories?: HaloCategory[];
  tags?: HaloTag[];
  contributors?: HaloContributor[];
  owner?: HaloContributor;
}
```

### 11. ÊÄßËÉΩ‰ºòÂåñÁ≠ñÁï•

```typescript
// src/lib/performance.ts
export class PerformanceOptimizer {
  // ÊâπÈáèËØ∑Ê±Ç‰ºòÂåñ
  static async batchFetch<T>(
    items: string[],
    fetcher: (name: string) => Promise<T>,
    batchSize = 5
  ): Promise<T[]> {
    const results: T[] = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize);
      const batchResults = await Promise.allSettled(
        batch.map(fetcher)
      );
      
      batchResults.forEach(result => {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        }
      });
    }
    
    return results;
  }

  // ÂÜÖÂ≠òÁºìÂ≠ò
  private static memoryCache = new Map<string, { data: any; expiry: number }>();
  
  static get<T>(key: string): T | null {
    const cached = this.memoryCache.get(key);
    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }
    return null;
  }
  
  static set<T>(key: string, data: T, ttl = 300000): void { // 5ÂàÜÈíüÈªòËÆ§TTL
    this.memoryCache.set(key, {
      data,
      expiry: Date.now() + ttl,
    });
  }
}
```

### 12. ÊµãËØïÁ≠ñÁï•

```typescript
// __tests__/services/post-service.test.ts
import { PostService } from '@/services/post-service';
import { haloClient } from '@/lib/halo-client';

// Mock Halo client
jest.mock('@/lib/halo-client');

describe('PostService', () => {
  let postService: PostService;
  
  beforeEach(() => {
    postService = new PostService();
    jest.clearAllMocks();
  });

  describe('getPosts', () => {
    it('should fetch and transform posts correctly', async () => {
      const mockHaloPosts = [
        {
          metadata: { name: 'test-post', creationTimestamp: '2023-01-01T00:00:00Z' },
          spec: {
            title: 'Test Post',
            slug: 'test-post',
            excerpt: { autoGenerate: true },
            categories: [],
            tags: [],
            visible: 'PUBLIC',
            allowComment: true,
            pinned: false,
            priority: 0,
            owner: 'admin',
            deleted: false,
            publish: true,
          },
          status: {
            permalink: '/posts/test-post',
            excerpt: 'Test excerpt',
            lastModifyTime: '2023-01-01T00:00:00Z',
            commentsCount: 0,
            contributors: [],
            inProgress: false,
          },
          stats: { visit: 10, upvote: 2, comment: 0 },
        },
      ];

      (haloClient.publicApi.content.post.queryPosts as jest.Mock)
        .mockResolvedValueOnce({ data: { items: mockHaloPosts } });

      const result = await postService.getPosts();
      
      expect(result).toHaveLength(1);
      expect(result[0].metadata.title).toBe('Test Post');
      expect(result[0].slug).toBe('test-post');
    });

    it('should handle API errors gracefully', async () => {
      (haloClient.publicApi.content.post.queryPosts as jest.Mock)
        .mockRejectedValueOnce(new Error('API Error'));

      const result = await postService.getPosts();
      
      expect(result).toEqual([]);
    });
  });
});
```

## ÈÉ®ÁΩ≤ÈÖçÁΩÆ

### Docker ÈÖçÁΩÆ
```dockerfile
# Dockerfile
FROM node:18-alpine AS base
WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install --frozen-lockfile

COPY . .

# ÁéØÂ¢ÉÂèòÈáè
ENV HALO_API_BASE_URL=http://halo:8090
ENV HALO_ENABLE_FALLBACK=true
ENV HALO_CACHE_TIMEOUT=300

RUN pnpm build

EXPOSE 3000
CMD ["pnpm", "start"]
```

### ÁéØÂ¢ÉÂèòÈáèÊ∏ÖÂçï
```bash
# .env.production
HALO_API_BASE_URL=https://your-halo-instance.com
HALO_API_TOKEN=pat_your_production_token
HALO_ENABLE_FALLBACK=false
HALO_CACHE_TIMEOUT=600
HALO_RETRY_COUNT=3
HALO_RETRY_DELAY=1000
```

## ÁõëÊéßÂíåÊó•Âøó

### ÊÄßËÉΩÁõëÊéß
```typescript
// src/lib/monitoring.ts
export class PerformanceMonitor {
  static async measureApiCall<T>(
    name: string,
    apiCall: () => Promise<T>
  ): Promise<T> {
    const start = performance.now();
    
    try {
      const result = await apiCall();
      const duration = performance.now() - start;
      
      console.log(`üìä API Call [${name}]: ${duration.toFixed(2)}ms`);
      
      // ÂèëÈÄÅÂà∞ÁõëÊéßÊúçÂä°
      this.reportMetric(name, duration, 'success');
      
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      
      console.error(`üìä API Call [${name}] Failed: ${duration.toFixed(2)}ms`, error);
      
      // ÂèëÈÄÅÈîôËØØÊåáÊ†á
      this.reportMetric(name, duration, 'error');
      
      throw error;
    }
  }

  private static reportMetric(name: string, duration: number, status: string) {
    // ÈõÜÊàê Analytics ÊàñÁõëÊéßÊúçÂä°
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'api_call', {
        event_category: 'performance',
        event_label: name,
        value: Math.round(duration),
        custom_parameter_1: status,
      });
    }
  }
}
```

## ËøÅÁßªÊ£ÄÊü•Ê∏ÖÂçï

### ÂºÄÂèëÁéØÂ¢ÉÈ™åËØÅ
- [ ] Halo ÊúçÂä°Âô®ËøêË°åÊ≠£Â∏∏
- [ ] API ‰ª§ÁâåÈÖçÁΩÆÊ≠£Á°Æ
- [ ] ÁΩëÁªúËøûÊé•ÁïÖÈÄö
- [ ] ‰æùËµñÂåÖÂÆâË£ÖÂÆåÊàê

### ÂäüËÉΩÈ™åËØÅ
- [ ] ÊñáÁ´†ÂàóË°®ÊòæÁ§∫Ê≠£Â∏∏
- [ ] ÊñáÁ´†ËØ¶ÊÉÖÈ°µÊ∏≤ÊüìÊ≠£Á°Æ
- [ ] ÂàÜÁ±ªÂíåÊ†áÁ≠æÂäüËÉΩÊ≠£Â∏∏
- [ ] ÊêúÁ¥¢ÂäüËÉΩÊ≠£Â∏∏
- [ ] ËØÑËÆ∫Á≥ªÁªüÈõÜÊàê

### ÊÄßËÉΩÈ™åËØÅ
- [ ] È¶ñÂ±èÂä†ËΩΩÊó∂Èó¥ < 2Áßí
- [ ] API ÂìçÂ∫îÊó∂Èó¥ < 500ms
- [ ] ÁºìÂ≠òÂëΩ‰∏≠Áéá > 90%
- [ ] ÈîôËØØÁéá < 1%

### SEO È™åËØÅ
- [ ] ÂÖÉÊï∞ÊçÆÊ≠£Á°ÆÁîüÊàê
- [ ] ÁªìÊûÑÂåñÊï∞ÊçÆÂÆåÊï¥
- [ ] Á´ôÁÇπÂú∞ÂõæÊõ¥Êñ∞
- [ ] RSS ËÆ¢ÈòÖÊ≠£Â∏∏

## È£éÈô©ÊéßÂà∂

### È´ò‰ºòÂÖàÁ∫ßÈ£éÈô©
1. **API ÊúçÂä°‰∏çÂèØÁî®**
   - ÁºìËß£Êé™ÊñΩ: ÂÆûÁé∞ÂÆåÊï¥ÁöÑÈôçÁ∫ßÊú∫Âà∂
   - ÁõëÊéßÊé™ÊñΩ: ÂÅ•Â∫∑Ê£ÄÊü•ÂíåÊä•Ë≠¶

2. **Êï∞ÊçÆ‰∏ç‰∏ÄËá¥**
   - ÁºìËß£Êé™ÊñΩ: Êï∞ÊçÆÈ™åËØÅÂíåÁ±ªÂûãÊ£ÄÊü•
   - ÁõëÊéßÊé™ÊñΩ: Êï∞ÊçÆÂÆåÊï¥ÊÄßÊ£ÄÊü•

3. **ÊÄßËÉΩ‰∏ãÈôç**
   - ÁºìËß£Êé™ÊñΩ: Â§öÂ±ÇÁºìÂ≠òÁ≠ñÁï•
   - ÁõëÊéßÊé™ÊñΩ: ÊÄßËÉΩÊåáÊ†áÁõëÊéß

### ‰∏≠‰ºòÂÖàÁ∫ßÈ£éÈô©
1. **ÂÖºÂÆπÊÄßÈóÆÈ¢ò**
   - ÁºìËß£Êé™ÊñΩ: Ê∏êËøõÂºèËøÅÁßª
   - ÁõëÊéßÊé™ÊñΩ: ÂõûÂΩíÊµãËØï

2. **ÂÆâÂÖ®È£éÈô©**
   - ÁºìËß£Êé™ÊñΩ: ‰ª§ÁâåËΩÆÊç¢ÂíåÊùÉÈôêÊéßÂà∂
   - ÁõëÊéßÊé™ÊñΩ: ÂÆâÂÖ®ÂÆ°ËÆ°Êó•Âøó

## ÊàêÂäüÊ†áÂáÜ

1. **ÂäüËÉΩÂÆåÊï¥ÊÄß**: ÊâÄÊúâÁé∞ÊúâÂäüËÉΩÊ≠£Â∏∏Â∑•‰Ωú
2. **ÊÄßËÉΩÊåáÊ†á**: Êª°Ë∂≥Êó¢ÂÆöÊÄßËÉΩÁõÆÊ†á
3. **Áî®Êà∑‰ΩìÈ™å**: Êó†ÁºùËøÅÁßªÔºåÁî®Êà∑Êó†ÊÑüÁü•
4. **ÂºÄÂèë‰ΩìÈ™å**: API ÈõÜÊàêÁÆÄÂçïÊòìÁî®
5. **ÂèØÁª¥Êä§ÊÄß**: ‰ª£Á†ÅÁªìÊûÑÊ∏ÖÊô∞ÔºåÊñáÊ°£ÂÆåÂñÑ

Ëøô‰∏™ÊäÄÊúØËßÑËåÉ‰∏∫ Magic Portfolio ÈõÜÊàê Halo API Êèê‰æõ‰∫ÜÂÆåÊï¥ÁöÑÂÆûÊñΩË∑ØÂæÑÔºåÁ°Æ‰øùËøÅÁßªËøáÁ®ãÁöÑÂèØÊéßÊÄßÂíåÊàêÂäüÁéá„ÄÇ